/**
 * Campaign Chart Hook - Guardrail Tests
 * Story 5.6: Campaign Performance Chart
 * Generated by TEA *automate workflow
 *
 * Purpose: Prevent regressions on critical hook-level fixes (H-1 queryKey/select)
 * and validate error handling, data shape, and API contract.
 *
 * Separated from campaign-chart-guardrails.test.tsx because these tests need
 * the REAL useCampaignChart hook (not mocked), while component tests mock it.
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useCampaignChart } from '@/hooks/use-campaign-chart';
import type { CampaignStatsResponse } from '@/types/campaigns';

// ===========================================
// Mock campaigns API
// ===========================================

const mockFetchCampaignStats = vi.fn();
vi.mock('@/lib/api/campaigns', () => ({
  fetchCampaignStats: (...args: unknown[]) => mockFetchCampaignStats(...args),
}));

// Re-export CampaignApiError for error tests
vi.mock('@/types/campaigns', async () => {
  const actual = await vi.importActual<typeof import('@/types/campaigns')>('@/types/campaigns');
  return actual;
});

// ===========================================
// Helpers
// ===========================================

function createTestQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: { retry: false, gcTime: 0 },
    },
  });
}

function createWrapper() {
  const queryClient = createTestQueryClient();
  return function TestWrapper({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    );
  };
}

// ===========================================
// Mock Data
// ===========================================

function createMockResponse(count: number): CampaignStatsResponse {
  return {
    success: true,
    data: {
      data: Array.from({ length: count }, (_, i) => ({
        campaignId: i + 1,
        campaignName: `Campaign ${String.fromCharCode(65 + i)}`,
        delivered: 1000 * (count - i),
        opened: 300 * (count - i),
        clicked: 50 * (count - i),
        uniqueOpens: 250 * (count - i),
        uniqueClicks: 40 * (count - i),
        openRate: 30 - i * 3,
        clickRate: 5 - i * 0.5,
        hardBounce: 0,
        softBounce: 0,
        unsubscribe: 0,
        spam: 0,
        firstEvent: '2026-01-01T00:00:00Z',
        lastUpdated: '2026-01-15T00:00:00Z',
      })),
      pagination: { page: 1, limit: 100, total: count, totalPages: 1 },
    },
  };
}

// ===========================================
// P0: H-1 Fix: Single cache key (no limit in queryKey)
// ===========================================

describe('[P0] H-1 Fix: Single cache key (no limit in queryKey)', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('[P0] should use limit-independent queryKey - only 1 API call for different limits', async () => {
    mockFetchCampaignStats.mockResolvedValue(createMockResponse(5));
    const wrapper = createWrapper();

    // Render hook with limit=5
    const { result: r1 } = renderHook(
      () => useCampaignChart({ limit: 5 }),
      { wrapper }
    );

    await waitFor(() => {
      expect(r1.current.isLoading).toBe(false);
    });

    // Render hook with limit=20 on SAME wrapper (shared QueryClient)
    const { result: r2 } = renderHook(
      () => useCampaignChart({ limit: 20 }),
      { wrapper }
    );

    await waitFor(() => {
      expect(r2.current.isLoading).toBe(false);
    });

    // GUARDRAIL: Must make only 1 API call regardless of different limits
    // If limit were in queryKey, this would be 2 separate calls
    expect(mockFetchCampaignStats).toHaveBeenCalledTimes(1);
  });

  it('[P0] should apply slicing via select (different limits, same cache)', async () => {
    mockFetchCampaignStats.mockResolvedValue(createMockResponse(5));
    const wrapper = createWrapper();

    // Render with limit=2
    const { result: r1 } = renderHook(
      () => useCampaignChart({ limit: 2 }),
      { wrapper }
    );

    await waitFor(() => {
      expect(r1.current.isLoading).toBe(false);
    });

    // GUARDRAIL: select should slice to 2 items
    expect(r1.current.data).toHaveLength(2);

    // Render with limit=4 on same client
    const { result: r2 } = renderHook(
      () => useCampaignChart({ limit: 4 }),
      { wrapper }
    );

    await waitFor(() => {
      expect(r2.current.isLoading).toBe(false);
    });

    // GUARDRAIL: select should now return 4 items from same cache
    expect(r2.current.data).toHaveLength(4);

    // Only 1 API call total
    expect(mockFetchCampaignStats).toHaveBeenCalledTimes(1);
  });

  it('[P0] should apply truncation via select (not queryFn)', async () => {
    const longNameResponse: CampaignStatsResponse = {
      success: true,
      data: {
        data: [
          {
            campaignId: 1,
            campaignName: 'Very Long Campaign Name That Exceeds Twenty Five Characters',
            delivered: 5000,
            opened: 1500,
            clicked: 250,
            uniqueOpens: 1200,
            uniqueClicks: 200,
            openRate: 30.0,
            clickRate: 5.0,
            hardBounce: 0,
            softBounce: 0,
            unsubscribe: 0,
            spam: 0,
            firstEvent: '2026-01-01T00:00:00Z',
            lastUpdated: '2026-01-15T00:00:00Z',
          },
        ],
        pagination: { page: 1, limit: 100, total: 1, totalPages: 1 },
      },
    };
    mockFetchCampaignStats.mockResolvedValue(longNameResponse);
    const wrapper = createWrapper();

    // Render with truncateLength=25
    const { result: r1 } = renderHook(
      () => useCampaignChart({ truncateLength: 25 }),
      { wrapper }
    );

    await waitFor(() => {
      expect(r1.current.isLoading).toBe(false);
    });

    expect(r1.current.data![0].campaignName).toBe('Very Long Campaign Name T...');

    // Render with truncateLength=10 on same wrapper
    const { result: r2 } = renderHook(
      () => useCampaignChart({ truncateLength: 10 }),
      { wrapper }
    );

    await waitFor(() => {
      expect(r2.current.isLoading).toBe(false);
    });

    // GUARDRAIL: Different truncation from SAME cache (select, not queryFn)
    expect(r2.current.data![0].campaignName).toBe('Very Long ...');

    // Only 1 API call
    expect(mockFetchCampaignStats).toHaveBeenCalledTimes(1);
  });
});

// ===========================================
// P1: Error Handling
// ===========================================

describe('[P1] useCampaignChart Error Handling', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('[P1] should wrap TypeError in CampaignApiError', async () => {
    mockFetchCampaignStats.mockRejectedValue(new TypeError('fetch failed'));

    const { result } = renderHook(() => useCampaignChart(), {
      wrapper: createWrapper(),
    });

    await waitFor(
      () => {
        expect(result.current.isError).toBe(true);
      },
      { timeout: 10000 }
    );

    // GUARDRAIL: Error should be wrapped in CampaignApiError
    expect(result.current.error).toBeTruthy();
    expect(result.current.error!.name).toBe('CampaignApiError');
    expect(result.current.error!.message).toBe('fetch failed');
  });

  it('[P1] should return a callable refetch function', async () => {
    mockFetchCampaignStats.mockResolvedValue(createMockResponse(1));

    const { result } = renderHook(() => useCampaignChart(), {
      wrapper: createWrapper(),
    });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    // GUARDRAIL: refetch must be a function
    expect(typeof result.current.refetch).toBe('function');
  });
});

// ===========================================
// P1: Data Shape Contract
// ===========================================

describe('[P1] useCampaignChart Data Shape Contract', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('[P1] should return only ChartDataItem fields (no leaking)', async () => {
    mockFetchCampaignStats.mockResolvedValue(createMockResponse(1));

    const { result } = renderHook(() => useCampaignChart(), {
      wrapper: createWrapper(),
    });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    const item = result.current.data![0];

    // GUARDRAIL: Must have ChartDataItem fields
    expect(item).toHaveProperty('campaignName');
    expect(item).toHaveProperty('campaignId');
    expect(item).toHaveProperty('openRate');
    expect(item).toHaveProperty('clickRate');
    expect(item).toHaveProperty('delivered');

    // GUARDRAIL: Must NOT have CampaignStatsItem extra fields
    expect(item).not.toHaveProperty('opened');
    expect(item).not.toHaveProperty('clicked');
    expect(item).not.toHaveProperty('uniqueOpens');
    expect(item).not.toHaveProperty('uniqueClicks');
    expect(item).not.toHaveProperty('firstEvent');
    expect(item).not.toHaveProperty('lastUpdated');
    expect(item).not.toHaveProperty('hardBounce');
    expect(item).not.toHaveProperty('softBounce');
  });

  it('[P1] should pass sortBy Open_Rate and sortOrder desc to API', async () => {
    mockFetchCampaignStats.mockResolvedValue(createMockResponse(1));

    renderHook(() => useCampaignChart(), { wrapper: createWrapper() });

    await waitFor(() => {
      expect(mockFetchCampaignStats).toHaveBeenCalledWith({
        limit: 100,
        sortBy: 'Open_Rate',
        sortOrder: 'desc',
      });
    });
  });

  it('[P1] should always fetch limit=100 regardless of requested limit', async () => {
    mockFetchCampaignStats.mockResolvedValue(createMockResponse(3));

    renderHook(() => useCampaignChart({ limit: 5 }), { wrapper: createWrapper() });

    await waitFor(() => {
      // GUARDRAIL: API always receives limit=100, client slices
      expect(mockFetchCampaignStats).toHaveBeenCalledWith(
        expect.objectContaining({ limit: 100 })
      );
    });
  });
});

// ===========================================
// P1: Enabled Flag
// ===========================================

describe('[P1] useCampaignChart Enabled Flag', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('[P1] should not fetch when enabled is false', () => {
    const { result } = renderHook(
      () => useCampaignChart({ enabled: false }),
      { wrapper: createWrapper() }
    );

    expect(mockFetchCampaignStats).not.toHaveBeenCalled();
    expect(result.current.data).toBeUndefined();
    expect(result.current.isLoading).toBe(false);
  });

  it('[P1] should fetch when enabled is true (default)', async () => {
    mockFetchCampaignStats.mockResolvedValue(createMockResponse(1));

    renderHook(() => useCampaignChart(), { wrapper: createWrapper() });

    await waitFor(() => {
      expect(mockFetchCampaignStats).toHaveBeenCalledTimes(1);
    });
  });
});
