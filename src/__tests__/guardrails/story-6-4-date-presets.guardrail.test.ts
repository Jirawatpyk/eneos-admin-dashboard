/**
 * TEA Guardrail Tests — Story 6.4: Custom Date Range (Utilities)
 * Generated by TEA *automate workflow
 *
 * Tests coverage gaps identified during post-implementation analysis:
 * - [P0] EXPORT_PRESETS frozen contract — type/label pairs cannot drift
 * - [P0] validateDateRange error message string contracts (used by UI)
 * - [P0] getExportDateRange quarter boundary correctness (Q1–Q4 transitions)
 * - [P1] validateDateRange fine-grained boundary days (0, 1, 364, 365, 366)
 * - [P1] getExportDateRange month boundary edge cases (Jan 1, Feb 28, last-of-month)
 * - [P2] validateDateRange with both undefined (empty range object)
 * - [P2] EXPORT_PRESETS deep-frozen type safety (ExportPresetType exhaustiveness)
 *
 * Note: Component guardrail tests are in story-6-4-custom-date-range.guardrail.test.tsx
 */
import { describe, it, expect, vi, afterEach } from 'vitest';
import {
  getExportDateRange,
  validateDateRange,
  EXPORT_PRESETS,
  type ExportPresetType,
} from '@/lib/export-date-presets';
import { addDays, subDays } from 'date-fns';

// ── P0: EXPORT_PRESETS Frozen Contract ──────────────────────────────

describe('[P0] EXPORT_PRESETS frozen contract', () => {
  // GUARDRAIL: If someone adds/removes/reorders presets, these break.
  // The UI iterates this array — any change is a visible regression.

  it('has exactly 4 presets (no more, no less)', () => {
    expect(EXPORT_PRESETS).toHaveLength(4);
  });

  it('type→label pairs are frozen', () => {
    expect(EXPORT_PRESETS).toEqual([
      { type: 'thisMonth', label: 'This Month' },
      { type: 'lastMonth', label: 'Last Month' },
      { type: 'thisQuarter', label: 'This Quarter' },
      { type: 'thisYear', label: 'This Year' },
    ]);
  });

  it('preset order matches render order (thisMonth first, thisYear last)', () => {
    expect(EXPORT_PRESETS[0].type).toBe('thisMonth');
    expect(EXPORT_PRESETS[3].type).toBe('thisYear');
  });

  it('all preset types are valid ExportPresetType values', () => {
    const validTypes: ExportPresetType[] = ['thisMonth', 'lastMonth', 'thisQuarter', 'thisYear'];
    EXPORT_PRESETS.forEach((preset) => {
      expect(validTypes).toContain(preset.type);
    });
  });
});

// ── P0: validateDateRange Error Message Contracts ───────────────────

describe('[P0] validateDateRange error message contracts', () => {
  // GUARDRAIL: The UI renders these exact strings in the blue info banner.
  // Changing them silently breaks the UX without any test catching it.

  it('exceeds-1-year error message is exact string used by ExportDateRangePicker', () => {
    const from = new Date(2025, 0, 1);
    const to = addDays(from, 366);
    const result = validateDateRange({ from, to });
    expect(result.error).toBe('Date range cannot exceed 1 year');
  });

  it('negative-range error message is exact string used by ExportDateRangePicker', () => {
    const from = new Date(2026, 5, 30);
    const to = new Date(2026, 0, 1);
    const result = validateDateRange({ from, to });
    expect(result.error).toBe('Start date must be before end date');
  });

  it('valid range returns no error property', () => {
    const from = new Date(2026, 0, 1);
    const to = new Date(2026, 3, 15);
    const result = validateDateRange({ from, to });
    expect(result.valid).toBe(true);
    expect(result.error).toBeUndefined();
  });
});

// ── P0: getExportDateRange Quarter Boundary Correctness ─────────────

describe('[P0] getExportDateRange quarter boundaries', () => {
  // GUARDRAIL: Quarter calculation is the most error-prone preset.
  // date-fns startOfQuarter maps months correctly but off-by-one is common.

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('Q1 (January) — quarter start is Jan 1', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date(2026, 0, 15)); // Jan 15
    const range = getExportDateRange('thisQuarter');
    expect(range.from!.getMonth()).toBe(0); // January
    expect(range.from!.getDate()).toBe(1);
    vi.useRealTimers();
  });

  it('Q2 (April) — quarter start is Apr 1', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date(2026, 4, 20)); // May 20
    const range = getExportDateRange('thisQuarter');
    expect(range.from!.getMonth()).toBe(3); // April
    expect(range.from!.getDate()).toBe(1);
    vi.useRealTimers();
  });

  it('Q3 (July) — quarter start is Jul 1', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date(2026, 7, 10)); // Aug 10
    const range = getExportDateRange('thisQuarter');
    expect(range.from!.getMonth()).toBe(6); // July
    expect(range.from!.getDate()).toBe(1);
    vi.useRealTimers();
  });

  it('Q4 (October) — quarter start is Oct 1', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date(2026, 11, 25)); // Dec 25
    const range = getExportDateRange('thisQuarter');
    expect(range.from!.getMonth()).toBe(9); // October
    expect(range.from!.getDate()).toBe(1);
    vi.useRealTimers();
  });

  it('first day of quarter — from equals to date (range = single day)', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date(2026, 3, 1)); // Apr 1 = Q2 start
    const range = getExportDateRange('thisQuarter');
    expect(range.from!.getDate()).toBe(1);
    expect(range.to!.getDate()).toBe(1);
    expect(range.from!.getMonth()).toBe(3);
    expect(range.to!.getMonth()).toBe(3);
    vi.useRealTimers();
  });
});

// ── P1: validateDateRange Boundary Day Precision ────────────────────

describe('[P1] validateDateRange boundary day precision', () => {
  // GUARDRAIL: Off-by-one in differenceInDays is a common bug.
  // MAX_RANGE_DAYS=365 — testing around the boundary.

  it('day 0 (same day) is valid', () => {
    const d = new Date(2026, 5, 15);
    expect(validateDateRange({ from: d, to: d }).valid).toBe(true);
  });

  it('day 1 is valid', () => {
    const from = new Date(2026, 0, 1);
    const to = addDays(from, 1);
    expect(validateDateRange({ from, to }).valid).toBe(true);
  });

  it('day 364 is valid', () => {
    const from = new Date(2026, 0, 1);
    const to = addDays(from, 364);
    expect(validateDateRange({ from, to }).valid).toBe(true);
  });

  it('day 365 (exact boundary) is valid', () => {
    const from = new Date(2026, 0, 1);
    const to = addDays(from, 365);
    expect(validateDateRange({ from, to }).valid).toBe(true);
  });

  it('day 366 (one over boundary) is invalid', () => {
    const from = new Date(2026, 0, 1);
    const to = addDays(from, 366);
    expect(validateDateRange({ from, to }).valid).toBe(false);
  });

  it('day 730 (2 years) is invalid', () => {
    const from = new Date(2024, 0, 1);
    const to = addDays(from, 730);
    expect(validateDateRange({ from, to }).valid).toBe(false);
  });

  it('negative 1 day (from > to by 1 day) is invalid', () => {
    const from = new Date(2026, 5, 2);
    const to = subDays(from, 1);
    expect(validateDateRange({ from, to }).valid).toBe(false);
    expect(validateDateRange({ from, to }).error).toBe('Start date must be before end date');
  });
});

// ── P1: getExportDateRange Month Boundary Edge Cases ────────────────

describe('[P1] getExportDateRange month boundary edge cases', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('thisMonth on Jan 1 — range is a single day', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date(2026, 0, 1));
    const range = getExportDateRange('thisMonth');
    expect(range.from!.getDate()).toBe(1);
    expect(range.to!.getDate()).toBe(1);
    vi.useRealTimers();
  });

  it('lastMonth in March — returns full February (28 days in non-leap year)', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date(2026, 2, 15)); // Mar 15, 2026 (non-leap)
    const range = getExportDateRange('lastMonth');
    expect(range.from!.getMonth()).toBe(1); // February
    expect(range.from!.getDate()).toBe(1);
    expect(range.to!.getMonth()).toBe(1);
    expect(range.to!.getDate()).toBe(28);
    vi.useRealTimers();
  });

  it('lastMonth in March of leap year — returns Feb 29', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date(2028, 2, 10)); // Mar 10, 2028 (leap year)
    const range = getExportDateRange('lastMonth');
    expect(range.from!.getMonth()).toBe(1);
    expect(range.to!.getDate()).toBe(29);
    vi.useRealTimers();
  });

  it('thisYear on Jan 1 — range is a single day', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date(2026, 0, 1));
    const range = getExportDateRange('thisYear');
    expect(range.from!.getMonth()).toBe(0);
    expect(range.from!.getDate()).toBe(1);
    expect(range.to!.getMonth()).toBe(0);
    expect(range.to!.getDate()).toBe(1);
    vi.useRealTimers();
  });

  it('lastMonth in January — returns full December of previous year', () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date(2026, 0, 20)); // Jan 20, 2026
    const range = getExportDateRange('lastMonth');
    expect(range.from!.getFullYear()).toBe(2025);
    expect(range.from!.getMonth()).toBe(11); // December
    expect(range.to!.getDate()).toBe(31);
    vi.useRealTimers();
  });
});

// ── P2: validateDateRange Edge Cases ────────────────────────────────

describe('[P2] validateDateRange edge cases', () => {
  it('both from and to undefined — valid (empty range object)', () => {
    const result = validateDateRange({ from: undefined, to: undefined });
    expect(result.valid).toBe(true);
  });

  it('from is undefined, to is defined — valid (incomplete)', () => {
    const result = validateDateRange({ from: undefined, to: new Date() });
    expect(result.valid).toBe(true);
  });

  it('year-end to year-start crossing — validates correctly', () => {
    const from = new Date(2025, 11, 1); // Dec 1, 2025
    const to = new Date(2026, 2, 1); // Mar 1, 2026 (90 days)
    expect(validateDateRange({ from, to }).valid).toBe(true);
  });

  it('from and to at different times on same day — valid (0 days)', () => {
    const from = new Date(2026, 5, 15, 8, 0, 0);
    const to = new Date(2026, 5, 15, 18, 0, 0);
    expect(validateDateRange({ from, to }).valid).toBe(true);
  });
});
