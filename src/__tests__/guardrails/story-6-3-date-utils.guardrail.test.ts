/**
 * TEA Guardrail Tests — Story 6.3: Quick Reports (Date Utilities)
 * Generated by TEA *automate workflow
 *
 * Tests coverage gaps identified during post-implementation analysis:
 * - [P0] getReportDateRange contract (return type, boundaries)
 * - [P1] Weekly range Monday start on different days of the week
 * - [P1] formatReportDateLabel format strings contract
 * - [P2] Monthly range on different months (28/30/31 day months)
 * - [P2] Daily range time boundaries (00:00:00 to 23:59:59)
 *
 * Note: Existing dev tests cover basic Saturday case. These guardrails
 * test boundary conditions across different days of the week.
 */
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import {
  getReportDateRange,
  formatReportDateLabel,
  type ReportType,
} from '@/lib/report-date-utils';

describe('Story 6.3 Date Utils — Guardrail Tests', () => {
  afterEach(() => {
    vi.useRealTimers();
  });

  // ── P0: getReportDateRange Return Type Contract ──────────────────
  /**
   * GUARDRAIL: getReportDateRange returns DateRange from react-day-picker.
   * Both `from` and `to` MUST be defined Date objects for all report types.
   * This contract is critical because ExportParams.dateRange uses these values
   * directly - undefined would break the export API call.
   */
  describe('[P0] getReportDateRange Return Type Contract', () => {
    beforeEach(() => {
      vi.useFakeTimers();
      vi.setSystemTime(new Date(2026, 0, 15, 10, 0, 0)); // Jan 15, 2026 (Thursday)
    });

    it.each<ReportType>(['daily', 'weekly', 'monthly'])(
      '%s type returns defined from and to dates',
      (type) => {
        // WHEN: Getting date range
        const range = getReportDateRange(type);

        // THEN: Both dates are defined Date objects
        expect(range.from).toBeInstanceOf(Date);
        expect(range.to).toBeInstanceOf(Date);
        expect(range.from).toBeDefined();
        expect(range.to).toBeDefined();
      }
    );

    it.each<ReportType>(['daily', 'weekly', 'monthly'])(
      '%s type: from is before or equal to "to"',
      (type) => {
        // WHEN: Getting date range
        const range = getReportDateRange(type);

        // THEN: from <= to
        expect(range.from!.getTime()).toBeLessThanOrEqual(range.to!.getTime());
      }
    );
  });

  // ── P1: Weekly Monday Start Across All Days ──────────────────────
  /**
   * GUARDRAIL: Weekly range MUST always start on Monday (weekStartsOn: 1).
   * This is the Thai business standard (ISO 8601). Testing on every day
   * of the week ensures the date-fns startOfWeek config isn't broken.
   */
  describe('[P1] Weekly Monday Start Boundary', () => {
    // Jan 2026 calendar:
    // Mon 12, Tue 13, Wed 14, Thu 15, Fri 16, Sat 17, Sun 18
    const weekDays = [
      { label: 'Monday', date: new Date(2026, 0, 12, 12, 0, 0), expectedMonday: 12 },
      { label: 'Tuesday', date: new Date(2026, 0, 13, 12, 0, 0), expectedMonday: 12 },
      { label: 'Wednesday', date: new Date(2026, 0, 14, 12, 0, 0), expectedMonday: 12 },
      { label: 'Thursday', date: new Date(2026, 0, 15, 12, 0, 0), expectedMonday: 12 },
      { label: 'Friday', date: new Date(2026, 0, 16, 12, 0, 0), expectedMonday: 12 },
      { label: 'Saturday', date: new Date(2026, 0, 17, 12, 0, 0), expectedMonday: 12 },
      { label: 'Sunday', date: new Date(2026, 0, 18, 12, 0, 0), expectedMonday: 12 },
    ];

    it.each(weekDays)(
      'on $label, weekly range starts on Monday (day $expectedMonday)',
      ({ date, expectedMonday }) => {
        vi.useFakeTimers();
        vi.setSystemTime(date);

        // WHEN: Getting weekly range
        const range = getReportDateRange('weekly');

        // THEN: from is Monday
        expect(range.from!.getDay()).toBe(1); // 1 = Monday
        expect(range.from!.getDate()).toBe(expectedMonday);
        expect(range.from!.getMonth()).toBe(0); // January
      }
    );
  });

  // ── P1: Daily Range Time Boundaries ──────────────────────────────
  describe('[P1] Daily Range Time Boundaries', () => {
    beforeEach(() => {
      vi.useFakeTimers();
      vi.setSystemTime(new Date(2026, 0, 31, 14, 30, 0));
    });

    it('daily from starts at 00:00:00', () => {
      const range = getReportDateRange('daily');

      expect(range.from!.getHours()).toBe(0);
      expect(range.from!.getMinutes()).toBe(0);
      expect(range.from!.getSeconds()).toBe(0);
    });

    it('daily to ends at 23:59:59', () => {
      const range = getReportDateRange('daily');

      expect(range.to!.getHours()).toBe(23);
      expect(range.to!.getMinutes()).toBe(59);
      expect(range.to!.getSeconds()).toBe(59);
    });
  });

  // ── P1: formatReportDateLabel Format Strings ─────────────────────
  /**
   * GUARDRAIL: Date label formats are part of the UI contract.
   * Changing these changes what managers see on their report cards.
   */
  describe('[P1] formatReportDateLabel Format Contract', () => {
    beforeEach(() => {
      vi.useFakeTimers();
    });

    it('daily format is "MMM d, yyyy" (short month)', () => {
      vi.setSystemTime(new Date(2026, 5, 15, 10, 0, 0)); // Jun 15
      const label = formatReportDateLabel('daily');
      expect(label).toBe('Jun 15, 2026');
    });

    it('weekly format is "MMM d - MMM d, yyyy" (range)', () => {
      vi.setSystemTime(new Date(2026, 5, 17, 10, 0, 0)); // Jun 17 (Wednesday)
      const label = formatReportDateLabel('weekly');
      // Week starts Monday Jun 15
      expect(label).toBe('Jun 15 - Jun 17, 2026');
    });

    it('monthly format is "MMMM yyyy" (full month name)', () => {
      vi.setSystemTime(new Date(2026, 5, 15, 10, 0, 0)); // June
      const label = formatReportDateLabel('monthly');
      expect(label).toBe('June 2026');
    });
  });

  // ── P2: Monthly Range Across Different Months ────────────────────
  describe('[P2] Monthly Range Boundary Cases', () => {
    beforeEach(() => {
      vi.useFakeTimers();
    });

    it('February (28 days, non-leap year 2026)', () => {
      vi.setSystemTime(new Date(2026, 1, 15, 10, 0, 0)); // Feb 15
      const range = getReportDateRange('monthly');

      expect(range.from!.getDate()).toBe(1);
      expect(range.from!.getMonth()).toBe(1); // February
    });

    it('March (31 days)', () => {
      vi.setSystemTime(new Date(2026, 2, 31, 10, 0, 0)); // Mar 31
      const range = getReportDateRange('monthly');

      expect(range.from!.getDate()).toBe(1);
      expect(range.from!.getMonth()).toBe(2); // March
      expect(range.to!.getDate()).toBe(31);
    });

    it('April (30 days)', () => {
      vi.setSystemTime(new Date(2026, 3, 30, 10, 0, 0)); // Apr 30
      const range = getReportDateRange('monthly');

      expect(range.from!.getDate()).toBe(1);
      expect(range.from!.getMonth()).toBe(3); // April
      expect(range.to!.getDate()).toBe(30);
    });

    it('first day of month', () => {
      vi.setSystemTime(new Date(2026, 0, 1, 10, 0, 0)); // Jan 1
      const range = getReportDateRange('monthly');

      expect(range.from!.getDate()).toBe(1);
      expect(range.to!.getDate()).toBe(1); // "to" is current date
    });
  });

  // ── P2: Weekly Cross-Month Boundary ──────────────────────────────
  describe('[P2] Weekly Cross-Month Boundary', () => {
    it('week starting in previous month', () => {
      vi.useFakeTimers();
      // Feb 3 2026 is Tuesday, so Monday = Feb 2
      vi.setSystemTime(new Date(2026, 1, 3, 10, 0, 0));
      const range = getReportDateRange('weekly');

      expect(range.from!.getDate()).toBe(2);
      expect(range.from!.getMonth()).toBe(1); // February
    });

    it('week crossing month boundary (e.g., Jan 31 is Saturday → Monday is Jan 26)', () => {
      vi.useFakeTimers();
      vi.setSystemTime(new Date(2026, 0, 31, 14, 0, 0)); // Saturday
      const range = getReportDateRange('weekly');

      expect(range.from!.getDate()).toBe(26); // Monday Jan 26
      expect(range.from!.getMonth()).toBe(0); // January
      expect(range.to!.getDate()).toBe(31);
    });
  });
});
